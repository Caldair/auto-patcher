#!/bin/bash

# version: beta v2.1.9, patches 2012.010.16.

# PDroid created by svyat. Official PDroid thread is 
# http://forum.xda-developers.com/showthread.php?t=1357056

# The Auto-Patcher created by pastime1971 and mateorod
# Thread and support for the Auto-Patcher can be found at
# http://forum.xda-developers.com/showthread.php?p=27589651#post27589651

# ChangeLog
# 2012.05.00. (v0.1) 
# ...........
# 2012.05.12. (v0.2) allows user to specify a different version of patches
# 2012.05.13. (v0.3.0) force "patch -N", remove temp upon failure, generate log output
# 2012.05.13. (v0.3.1) revised the generation of updater-script (SGS2)
# 2012.05.15. added AOSP patches
# 2012.05.15. added crespo-aosp patches, added device-specific patching if patch exists
# 2012.05.15. remove restore.zip upon failure
# 2012.05.15. (v0.4.1) added CM7 (GB) patches
# 2012.05.18. (v0.4.2) added checking for tool commands
# 2012.05.21. (v0.4.3) apply device-specific patche only when it is specified
# 2012.05.26. added task title to log
# 2012.05.31. (v0.4.4) CM9 patches updated, crespo-aosp added
# 2012.06.04. (v0.4.5) added checking tools and rom, added aroma installer support, add patch outputs reroute
# 2012.06.15. CM9 patches updated
# 2012.06.16. (v0.4.6) AOKP patches updated, patch versions restructured
# 2012.06.17. (v0.5.0) patcher script reorganized, removed build.prop
# 2012.06.17. (v0.6.0) auto patcher script for pdroid and v6 patches
# 2012.06.19. (v0.6.1) add patches for CM7.2 Final
# 2012.06.20. (v0.6.2) updated CM 7.2 patches
# 2012.06.23. (v0.6.3) fix symlinks
# 2012.06.26. (v0.6.4) added 0618 patches for cm7 nightlies; removed 0619 cm7.2 final
# 2012.06.27. (v0.6.5) added new CM9 patches (20120626)
# 2012.06.27. (v0.6.6) added CM7 nightly patches (20120625) (finally!)
# 2012.07.02. (v0.7.0) Redid AOSP/AOKP; add Windows support (using Cygwin). Thanks kobik77!
# 2012.07.06. (v0.7.1) updated CM9 patches (20120706)
# 2012.07.08. (v0.7.2) updated AOKP (20120707) and CM9 (20120708) pdroid patches
# 2012.07.11. (v1.0.0) reworked script works on Linux, Mac OSX, and Windows (on Cygwin); 
# 		        added new ICS/JellyBean support for the new V6-Supercharger
# 2012.07.18. (v1.0.1) new CM7/CM9 Pdroid patches (20120718)
# 2012.07.23. (v1.0.2) updated CM9 patches (20120723)
# 2012.07.23. (v1.0.3) updated CM9 patches (20120724)
# 2012.08.06. (v1.5.0) updated smali/baksmali binaries to 1.33
# 2012.08.06. 	       Added Pdroid/V6supercharger support for CM10 Jellybean!
# 2012.08.06.	       Improved PDroid stability and efficiency (Thanks CollegeDev)
# 2012.08.06. (v1.6.0) added aokp-jb patches for pdroid/v6supercharger, script update
# 2012.08.17. (v1.9.5) Added support for pdroid_addon, by CollegeDev.
#		       Added insecure boot.img mod
#		       Added support for aosp-jb (This needs testing, and may not be
#		              a wide patch due to large variation between AOSP roms. 
#                      		          -Please report all experiences!
#		       Updated all v6supercharger patches w/new edits to ProcessList
#                      Major script overhaul in preparation for additional mods!
# 2012.08.20. (1.9.6) Conditional support for Official cm10 and aokp-jb builds
# 2012.08.23. (1.9.7) Final/confirmed pdroid support for Official CM10 and AOKP-JB
# 2012.09.04  (1.9.8) Bundled cygwin-compatible tools (original was corrupt).
#						 For Cygwin, replaced h2b function with simple bash math
#						 conversion (req'd for compat w/ Cygwin tools).
# 2012.08.26. (2.0.0) Added .apk patching
#					  Added 3G Dongle support for Nexus 7
#                     TabletUI support for Nexus 7 (maybe more)
#					  Google Voice support for Nexus 7
#						mods are 3gdongle, tabletUI, voice, or nexus7suite (for all)
#					  Added provisional file copy menu to widen patching base
#
# 2012.09.11. (2.0.1) Cygwin support fixes
# 2012.09.11. (2.0.2) Bugfix for 3gdongle (all)
# 2012.09.16. (2.1.0) Significant restructuring of core operations; added edit text file
#		          fix for "method-cap" errors in pdroid.
# 2012.09.20. (2.1.1) Fix for Phone FC's; OSX support finalized; ContentResolver resolved
# 2012.09.28. (2.1.2) Hotfix for failed pdroid patching. Logging improvements.
# 2012.10.07. (2.1.5) Final pdroid support for CM7.2 Official Releases
#			Added aosp-mod patches for pdroid patching of AOSP kangs
#			Switched to Chainfire's (f)aapt for speed/space reasons
# 2012.10.13. (2.1.6) New PDroid patches for aokp-jb and cm10 4.1.2
#		        Revert (f)aapt- temporary due to reported issues
# 2012.10.15. (2.17)  New (again) CM10 pdroid patches.
#                     Move files to be copied into $p/$R/$B
#                       -This required a bunch of file moving-report broken symlinks. 
#                     Some error check on the old RIL delete functions (thanks bundrik)
# 2012.10.16. (2.1.7.5) Fix FC on phone with CM10 pdroid patches
# 2012.10.19. (2.1.9) Testing CM10 support for PDroid Extension by CollegeDev.
                    
# SHELL PROGRAMMING NOTES:
# [ -s FILE ] 
# [[ -n STRING ]] or [[ -z STRING ]] 

VERSION="Auto-Patcher v2.1.9"

echo ""
echo "The $VERSION"
echo ""
# by pastime1971 and mateorod
    	

# pass variables to children
set -a

# function for converting hex to binary- for testing
#function h2b { echo "obase=2; ibase=16; $( echo "$*" | sed -e 's/0x//g' -e 's/\([a-z]\)/\u\1/g' )" | bc; }

printusage () {
	echo "      The $VERSION"
	echo "      pdroid 1.32 patches 2012.09.13."
	echo "      v6supercharger patches 2012.08.17."
	echo ""
	echo "usage: $0 ROM.ZIP MODS [ROMTYPE] [PATCHDATE]"
	echo ""
	echo "MODS can be pdroid,v6supercharger or pdroid or v6supercharger"
	echo "optional [ROMTYPE] can be cm9, aokp, etc."
	echo "optional [PATCHDATE] can be specified to use older patch versions."
	echo "try \"$0 ROM.ZIP -h\" to see what is available"
	echo ""
	exit
}

debug () {
	echo "! please refer to $LOG for any debugging"
	echo ""
	echo "! patching failed."
	echo "! it may be possible to patch $ROM using other patch version"
	echo ""
	[ -d "$TEMP" ] && \rm -rf "$TEMP"
	printusage
}

printerror () {
	echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
	echo "!!! error: $@"
	echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
	echo ""	
	debug
}

printtask () {
	echo "" >> "$LOG"
	echo $@ | tee -a "$LOG"
}

copyfailed () {
	echo ""
	echo "File for which patching failed:"
	echo "---------------------------------------------"
	echo ""
	echo "${FAIL##*/}"
	echo ""
	echo "---------------------------------------------"
	echo ""
	echo "We can try to add a premade copy of those files."
	echo "This sometimes works."
	echo ""
	echo "But IT MAY NOT WORK!!!"
	echo ""
	echo ""
	askconsent && return 0 || return 1
}

askconsent () {
	sleep 1
	echo -n "Do you want to proceed ? (YES/no) "
	read PROCEED
	echo "askconsent intial = ${PROCEED}" >> "$LOG" 
	case $PROCEED in
		[Yy] | [Yy][Ee][Ss])
			echo ""
			;;
		*)
			return 1;	# error
			;;
	esac
	echo -n "Are you sure ? (YES/no) "
	read PROCEED
	echo "askconsent final = ${PROCEED}: for $FAIL" >> "$LOG"
	case $PROCEED in
		[Yy] | [Yy][Ee][Ss])
			return 0;	# successful
			;;
		*)
			return 1;	# error
			;;
	esac
}

abspath () {
	case `uname -s` in
	CYGWIN*)
		echo $(cygpath -ua "$1")
		;;
	Darwin)
		#[[ $(echo $1 | awk '/^\//') == $1 ]] && echo "$1" || echo "$PWD/$1"
		[[ ${1:0:1} == "/" ]] && echo "$1" || echo "$PWD/$1"
		;;
	Linux)
		echo $(readlink -f "$1")
		;;
	*)
		if [[ ${1:0:1} == "/" ]]; then
			echo "$1"
		elif [[ ${1:0:2} == "./" ]]; then
			echo "$PWD/${1:2}"
		else
			echo "$PWD/$1"
		fi
		;;
	esac
}

extpath () {
	case `uname -s` in
	CYGWIN*)
		echo $(cygpath -da "$1")
		;;
	*)
		echo $(abspath "$1")
		;;
	esac
}

#contains () { for e in "${@:2}"; do [[ "$e" = "$1" ]] && return 0; done; return 1; }

parse () { echo "${1%%_*}"; }

getbuildprop () {
if [ -f system/build.prop ]; then
	result=(`grep $1 system/build.prop | tr -d '\r' | tr '=' ' '`)
	echo "${result[1]}"
else
	echo ""
fi
}

proberom () {
	VID=$(getbuildprop ro.build.version.release)

	if [ "${VID%.*}" == "2.3" ]; then
		ANDR=gingerbread
		RID=cm;
	elif [ "${VID%.*}" == "4.0" ]; then
		ANDR=ics
		MID=$(getbuildprop ro.rommanager.developerid)
		[[ "$MID" == "" ]] && MID=$(parse $(getbuildprop ro.modversion))
		DID=$(getbuildprop ro.product.device)
		[[ "$DID" == "" ]] && DID=$(getbuildprop ro.build.product)

		case "$MID" in
		pa|cm9|cm|cyanogenmod*)
			RID=cm;
			;;
		aokp|teamkang)
			RID=aokp;
			;;
#		aosp|AOSP)	# AOSP probing does not work yet
#			RID=aosp;
#			;;
		*)
			RID=aosp; 
			echo "!!! $MID is not supported yet, trying generic latest !!!"
			;;
		esac
	elif [ "${VID%.*}" == "4.1" ]; then
		ANDR=jellybean
		MID=$(getbuildprop ro.build.display.id)
		[[ "$MID" == "" ]] && MID=$(parse $(getbuildprop ro.build.display.id))
		DID=$(getbuildprop ro.product.device)
		[[ "$DID" == "" ]] && DID=$(getbuildprop ro.build.product)

		case "$MID" in
		cm10|cm*|cyanogenmod*)
			RID=cm;
			;;
		aokp*|teamkang)
			RID=aokp;
			;;
                pa*)
                        RID=pa;
                        ;;
                *)
			aosp_mod_check;
			;;
		esac
	else
		printerror "unknown ROM version $VID"
	fi
	echo "... result of ROM check: version= $ANDR rom= $RID ..."
}

# NEW # Advanced build date query
# This should set the patch date automatically.

buildquery() {

if [ $# -gt 3 ]; then
	BID=${4//,/ };
elif 
[[ ${#PID[@]} -gt 1 ]]; then
        BID=latest;
else
   for P in ${PID[@]}; do
                [ -d patches/$P/$ANDR ] && A=$ANDR || A=all
		[ -d patches/$P/$A/$RID ] && R=$RID || R=generic
		[ -d patches/$P/$A/$R/$BID ] && B=$BID || B=latest
		PAR=patches/$P/$A/$R
		PARB=patches/$P/$A/$R/$B
	UTC=$(getbuildprop ro.build.date.utc)
	BDID=`date -d "1970-01-01 UTC $UTC seconds" +"%Y%m%d"`
        DATES=`ls patches/$P/$A/$R/ | grep '201*'`
        # attempt to set builds before extant patches to earliest
             for i in $DATES; do
                  if [[ $i -lt $BID ]]; then
                         BID=$i
                  fi
                  if [[ $(($BID-$BDID)) -lt 0 ]]; then
                         BID=$i
                  else
                       for g in $DATES; do
                           if [[ $(($BDID-$g)) -eq 0 ]]; then
                               BID=$g
                               break
                           elif [[ $(($BDID-$g)) -gt 0 ]] && [[ $g -gt $BID ]]; then
                                BID=$g
                           fi
                       done
                  fi
             done
        echo "$PID patch date has been set to: $BID"
        B=$BID
   done
fi
}
        

aosp_mod_check() {
        jar -xvf "$ROMX" system/framework/framework2.jar >> $LOG
                if [ -s system/framework/framework2.jar ]; then
                        RID=aosp-mod
                        echo "Framework2.jar found; defaulting to $RID"
                else
                        RID=aosp-jb
                        echo "No framework2.jar found; using $RID patches"
                fi
}
proberil () {
	RIL=$(getbuildprop ro.telephony.ril_class)
	[[ -n $RIL ]] && printtask "... result of ROM check: RIL= $RIL"
}

garbage () {
	unset GARBAGE
	GARBAGE=($(find $@ -name "*.orig")) && rm -rf ${GARBAGE[@]} && echo "GARBAGE= ${GARBAGE[@]}" >> "$LOG"
	GARBAGE=($(find $@ -name "*.rej"))  && rm -rf ${GARBAGE[@]} && echo "GARBAGE= ${GARBAGE[@]}" >> "$LOG"
}

rominfo () {
echo "# VER= $VERSION" >> "$LOG"
echo "# OS=  $OSTYPE ${BIT}bit" >> "$LOG"
echo "# VID= $VID" >> "$LOG"
echo "# PID= ${PID[@]}" >> "$LOG"
echo "# MID= $MID" >> "$LOG"
echo "# RID= $RID" >> "$LOG"
echo "# ANDR= $ANDR" >> "$LOG"
echo "# BDID= $BDID" >> "$LOG"
echo "# DID= $DID" >> "$LOG"
echo "# BID= $BID" >> "$LOG"

}

[[ $# -lt 1 || $1 == "-h" || -z $1 ]] && printusage

ROOT=$(abspath `dirname "$0"`)
TOOL="$ROOT/patch_tools.tgz"
PTCH="$ROOT/patch_patches.tgz"
ROM=$(abspath "$1")
ROMX=$(extpath "$1")

if [[ $OSTYPE == "cygwin" ]]; then
	EXE=".exe"
	PGFORM="0x"
fi

DATE=`date +%Y%m%d%H%M%S`
TEMP=$(abspath ./tmp$DATE)
LOG=$(abspath ./log$DATE)
#echo $ROOT $TOOL $ROM $TEMP "$LOG"
echo "ROOT= $ROOT" >> "$LOG"
echo "TOOL= $TOOL" >> "$LOG"
echo "ROM=  $ROM" >> "$LOG"
echo "ROMX= $ROMX" >> "$LOG"

\rm -f restore.zip update.zip

CHK=$(getconf LONG_BIT) 
if [[ $CHK = "64" ]]; then
	BIT=64
else [[ $BIT = "32" ]];
	BIT=32
fi


printtask "### verify tools ###"
which patch >> "$LOG" || printerror "Missing \"patch diff command\""
which tar >> "$LOG" || printerror "Missing \"tar archive command\""
which jar >> "$LOG" || printerror "Missing \"jar (JDK)\""
which java >> "$LOG" || printerror "Missing \"java (JRE)\""
which cpio >> "$LOG" || printerror "Missing \"cpio archive command\""
[ -f "$TOOL" ] || printerror "patch tool is missing"
[ -f "$PTCH" ] || printerror "patch patches are missing"
printtask "### verify ROM ###"
[ -f "$ROM" ] || printerror "Cannot find $ROM"
echo "### running $0 $@" >> "$LOG"
mkdir "$TEMP"
cd "$TEMP"

PATH="$TEMP:$PATH"
export PATH
echo "PATH= $PATH" >> "$LOG"

printtask "### unzip patch tools ###"
tar xvzf "$TOOL" > /dev/null || printerror "failed extracting tools !!!"

# Get OS specific tools
	case `uname -s` in
		CYGWIN*)
			\mv cygwin/aapt.exe .
			\mv cygwin/*.exe boot/
			\rm -rf cygwin # why? If you want to we can keep/add it to mac/linux, though.
			;;
		[Dd]arwin)
			\mv mac/aapt .
			;;
		[Ll]inux)
			\mv linux/aapt .
			;;
		*)
			\mv linux/aapt .
			;;	
	esac
		
printtask "### unzip patch patches ###"
tar xvzf "$PTCH" > /dev/null || printerror "failed extracting patches !!!"

# we need build.prop for both RIL probing and ROM probing
jar -xvf "$ROMX" system/build.prop 2>> "$LOG" || printerror "failed extracting build.prop from $ROMX !!!"

# rom + ril type
proberil
printtask "### probe rom type ###"
proberom

# rom type
if [ $# -gt 2 ]; then
	RID=$3
        if [ -z "$RID"=="cm*" ]; then
                RID="cm";
        elif [ -z "$RID"=="aokp*" ]; then
                RID="aokp"
        elif [ -z "$RID"=="pa*" ]; then
                RID="pa"
        elif [ -z "$RID"=="aosp*" ]; then
                aosp_mod_check
        fi
	echo "... Using $RID patches ..."
else
	echo "... Using results of ROM check ..."	
fi

# patch type
if [ $# -gt 1 ]; then
	PIL=${2//,/ }
else
	#PIL=`ls patches/`
	PIL="pdroid v6supercharger"
        echo "No mods selected. Defaulting to the v6 and Pdroid, just because we can."
fi
# a hack to make sure pdroid is the first mod
[[ ${PIL[@]} =~ pdroid ]] && PID=(pdroid)
for P in ${PIL[@]}; do
	[[ ${PID[@]} =~ $P ]] || PID=(${PID[@]} $P)
done

# Build date
if [ $# -gt 3 ]; then
	BID=$4
        echo "$PID patch date set manually to $BID"
else
        buildquery
fi

# echo ROM info
rominfo

if [[ ( "$PID" == "-h"  || "$ANDR" == "-h" || "$RID" == "-h" || "$BID" == "-h" ) ]]; then
	echo "### supported patch candidates ###"
	[ "$PID" != "-h" ] && PL=${PID[@]} || PL=`ls patches/`
	for P in ${PL[@]}; do
		[ "$PID" != "-h" -a "$RID" != "-h" ] && RL=${RID[@]} || RL=`ls patches/$P/$A`
		for R in ${RL[@]} ; do
			[ $R == "common" -o ! -d patches/$P/$A/$R ] && continue
			echo -n "$P :$A :$R : "
			\ls --ignore="*.sh" --ignore="*.txt" -r patches/$P/$A/$R/
		done
	done
else
	for P in ${PID[@]}; do
		[ -d patches/$P ] || printerror "$P is not available"
                [ -d patches/$P/$ANDR ] && R=$ANDR || A=all
		[ -d patches/$P/$A/$RID ] && R=$RID || R=generic
		#[ -d patches/$P/$A/$R/$BID ] && B=$BID || B=latest

		unset FILES
                [ -f patches/$P/files.txt ] && FILES=$(cat patches/$P/files.txt)
		[ -f patches/$P/$A/files.txt ] && FILES=$(cat patches/$P/$A/files.txt)
		[ -f patches/$P/$A/$R/files.txt ] && FILES=$(cat patches/$P/$A/$R/files.txt)
		for FILE in ${FILES[@]}; do
			case "$FILE" in
			+system/*)
				[[ ${CID[@]} =~ ${FILE:1} ]] && printerror "${FILE:1} is already being copied" || CID=(${CID[@]} ${FILE:1})
				;;
			-system/*)
				[[ ${EID[@]} =~ ${FILE:1} ]] || EID=(${EID[@]} ${FILE:1})
				;;
			system/*.jar)
				[[ ${JID[@]} =~ $FILE ]] || JID=(${JID[@]} $FILE)
				;;
			system/*.apk)
				[[ ${AID[@]} =~ $FILE ]] || AID=(${AID[@]} $FILE)
				;;
			*.img)
				[[ ${IID[@]} =~ $FILE ]] || IID=(${IID[@]} $FILE)
				;;
			system/*)
				[[ ${TID[@]} =~ $FILE ]] || TID=(${TID[@]} $FILE)
				;;
			esac
		done
	done
	echo "### DELETE FILES= ${EID[@]}" >> "$LOG"
	echo "### COPY FILES= ${CID[@]}" >> "$LOG"
	echo "### JAR FILES= ${JID[@]}" >> "$LOG"
	echo "### APK FILES= ${AID[@]}" >> "$LOG"
	echo "### IMG FILES= ${IID[@]}" >> "$LOG"
	echo "### TXT FILES= ${TID[@]}" >> "$LOG"

	printtask "### unzip rom ###"
	# extract system files
	jar -xvf "$ROMX" ${JID[@]} ${AID[@]} ${IID[@]} ${TID[@]} 2>> "$LOG" || printerror "failed extracting ${JID[@]} ${AID[@]} ${IID[@]} from $ROMX !!!"
	#\cp -a system/ backup	# only for debugging purpose

	printtask "### create updater script ###"
	jar -xvf "$ROMX" META-INF/com/google/android/updater-script META-INF/com/google/android/update-binary
	jar -xvf "$ROMX" META-INF/com/google/android/update-binary-installer 1> /dev/null 2> /dev/null
	if [ -f META-INF/com/google/android/update-binary-installer ]; then
		printtask "... using Aroma installer ..."
		\mv META-INF/com/google/android/update-binary-installer META-INF/com/google/android/update-binary
	else
		printtask "... using Clockworkmod installer ..."
	fi
	if [ -f META-INF/com/google/android/update-binary ]; then
		#echo "# original updater-script" >> "$LOG"
		#cat META-INF/com/google/android/updater-script >> "$LOG"

		cat META-INF/com/google/android/updater-script | grep ^mount | grep "/system" | head -n 1 > updater-script
		[ -s updater-script ] || echo "run_program(\"/sbin/busybox\", \"mount\", \"/system\");" > updater-script

		for FILE in ${EID[@]}; do
			# restore the original
			jar -xvf "$ROMX" $FILE 2> /dev/null || printtask "!!! warning $FILE cannot be restored !!!"
		done
		for FILE in ${CID[@]}; do
			# replace with the original or delete it
			jar -xvf "$ROMX" $FILE 2> /dev/null || echo "delete(\"/$FILE\");" >> updater-script
		done

		echo "package_extract_dir(\"system\", \"/system\");" >> updater-script
		# add permission management
		cat META-INF/com/google/android/updater-script | grep set_perm | grep "/system" >> updater-script
		# TODO: remove if we don't need it any more
		for P in ${PID[@]}; do
			if [ -s patches/$P/set_perm.txt ]; then
				echo "...adding permissions..."
				cat patches/$P/$A/set_perm.txt >> updater-script
			fi
		done

		cat META-INF/com/google/android/updater-script | grep ^unmount | grep "/system" | head -n 1 >> updater-script

		[[ ${IID[@]} =~ boot.img ]] && cat META-INF/com/google/android/updater-script | grep "boot.img" >> updater-script

		cat updater-script > META-INF/com/google/android/updater-script

		echo "# generated updater-script" >> "$LOG"
		cat updater-script >> "$LOG"
	else
		# this is not enough any more
		jar -xvf update-template.zip META-INF/com/google/android/update-binary META-INF/com/google/android/updater-script
	fi

	printtask "### create restore.zip ###"
	jar -cfv tmp.zip ${JID[@]} ${AID[@]} ${IID[@]} META-INF > /dev/null 2>> "$LOG"
	java -jar signapk.jar updatecert.pem updatekey.pk8 tmp.zip signed.zip 2>> "$LOG"
	\mv signed.zip restore.zip
	\rm -f tmp.zip

	printtask "### decompile system files ###"

	# decompile system files
	for FILE in ${JID[@]}; do
		JAR=${FILE##*/}
		printtask "... decompile $JAR ..."
		java -jar baksmali.jar -b -a 15 -o tmp/${FILE}.out/smali ${FILE} >> "$LOG" 2>> "$LOG"
		if [ $FILE == "system/framework/framework.jar" ]; then
			printtask "... extract preloaded-classes ..."
			jar -xvf ${FILE} preloaded-classes >> "$LOG" 2>> "$LOG"
			\mv preloaded-classes tmp/${FILE}.out/
		fi
	done
	for FILE in ${AID[@]}; do
		APK=${FILE##*/}
		printtask "... decompile $APK ..."
		if [ $FILE == "system/framework/framework-res.apk" ]; then
			printtask "... installing framework files ..."
			java -jar apktool.jar if $FILE
		fi
		java -jar apktool.jar d -f $FILE tmp/$FILE.out
		
	done
	for FILE in ${IID[@]}; do
		printtask "### unpacking $FILE ###"
		case "$FILE" in
			boot.img)
				cd boot
				./unpackbootimg$EXE -i ../boot.img >> "$LOG" 2>> "$LOG"

				mkdir ramdisk
				cd ramdisk
				gzip -dc ../boot.img-ramdisk.gz | cpio -i >> "$LOG" 2>> "$LOG"
				cd ../../
				;;
			*)
				printerror "cannot process $FILE"
				;;
		esac
	done


	# apply system modification

        for P in ${PID[@]}; do
                [ -d patches/$P/$ANDR ] && A=$ANDR || A=all
		[ -d patches/$P/$A/$RID ] && R=$RID || R=generic
		[ -d patches/$P/$A/$R/$BID ] && B=$BID || B=latest
		PAR=patches/$P/$A/$R
		PARB=patches/$P/$A/$R/$B

		unset FILES COPY DELS JARS APKS IMGS TXTS
		[ -f patches/$P/$A/files.txt ] && FILES=$(cat patches/$P/$A/files.txt)
		[ -f patches/$P/$A/$R/files.txt ] && FILES=$(cat patches/$P/$A/$R/files.txt)
		for FILE in ${FILES[@]}; do
			case $FILE in
			+system/*)
				COPY=(${COPY[@]} ${FILE:1})
				;;
			-system/*)
				DELS=(${DELS[@]} ${FILE:1})
				;;
			system/*.jar)
				JARS=(${JARS[@]} $FILE)
				;;
			system/*.apk)
				APKS=(${APKS[@]} $FILE)
				;;
			*.img)
				IMGS=(${IMGS[@]} $FILE)
				;;
			system/*)
				TXTS=(${TXTS[@]} $FILE)
				;;
			esac
		done

		[[ -n ${COPY[@]} ]] && printtask "### copy patch $P/$A/$R/$B ###"
		for FILE in ${COPY[@]}; do 
			printtask "... copying $FILE ..."
			DEST=${FILE%/*}
			mkdir -p ./$DEST
			if [ -e patches/$P/$A/$R/$B/$FILE ]; then
				[ -e $FILE ] && printtask "... overwriting $FILE from $P ..."
	 			\cp -av patches/$P/$A/$R/$B/$FILE ./$DEST >> "$LOG"
			else
				printerror "$FILE is missing in the patch"
			fi
		done

		# unconditional smali copying
		[ -f patches/$P/smali.txt ] && SMALI=$(cat patches/$P/smali.txt)
                [ -f patches/$P/$A/smali.txt ] && SMALI=$(cat patches/$P/$A/smali.txt)
		[ -f patches/$P/$A/$R/smali.txt ] && SMALI=$(cat patches/$P/$A/$R/smali.txt)
		[ -f patches/$P/$A/$R/$B/smali.txt ] && SMALI=$(cat patches/$P/$A/$R/$B/smali.txt)
		MOVE=${SMALI##*/}
		for SMALI in ${SMALI[@]}; do
			printtask "... overwriting $MOVE ..."
				\cp -av patches/$P/$ANDR/provisionals/$SMALI tmp/$SMALI >> "$LOG"
		done


		[[ -n ${DELS[@]} ]] && printtask "### delete patch $P/$A/$R/$B ###"
		for FILE in ${DELS[@]}; do 
			printtask "... deleting $FILE ..."
	 		\rm -rf ./$FILE
		done

		[[ -n ${JARS[@]} ]] && printtask "### jar patch $P/$A/$R/$B ###"
		for FILE in ${JARS[@]}; do
			JAR=${FILE##*/}
			NAME=${JAR%.jar}
			printtask "... apply $NAME.patch ..."
			patch -Nls -p1 -d tmp/${FILE}.out < $PARB/${NAME}.patch 2>&1 > ${JAR}.log
			cat ${JAR}.log | tee -a "$LOG"
			case "$NAME" in
			framework)
				# patch preloaded-classes only if a patch exists
				if [ -f $PARB/preloaded.patch ]; then
					printtask "... apply preloaded.patch ..."
					patch -Nls -p1 -d tmp/${FILE}.out < $PARB/preloaded.patch 2>&1 > preloaded.log
					cat preloaded.log | tee -a "$LOG"
					[[ `grep FAILED preloaded.log` != "" ]] && printerror "failed preloaded.patch"
				fi
				;;
			*)
				echo -n ""	# do nothing else
				;;
			esac
			# substitute failed smali with premade jar
			unset FAILS
			FAILS=(`grep FAILED ${JAR}.log | sed -e 's/.*smali\///' | sed -e 's/\.rej//'`)
			if [[ -n ${FAILS[@]} ]]; then
				printtask "!!! PATCHING FAILED FOR ${FAILS[@]} !!!"
				echo "### replace ${FAILS[@]} ###" > ${JAR}.log
				for FAIL in ${FAILS[@]}; do
					echo "!!! patch error for $FAIL !!!" >> "$LOG"
					#cat tmp/$FILE.out/smali/${FAIL}.rej >> "$LOG"
					[[ ${SID[@]} =~ $FAIL ]] && printerror "$FAIL was already replaced before"
					[ -f patches/$P/$ANDR/provisionals/${FILE}.out/smali/${FAIL} ] || printerror "failed $FAIL in $JAR cannot be remedied"
					copyfailed || printerror "failed $NAME.patch"
					printtask "... replace $FAIL ..."
					\rm -rf tmp/${FILE}.out/smali/${FAIL} tmp/${FILE}.out/smali/${FAIL}.orig tmp/${FILE}.out/smali/${FAIL}.rej
					\cp -av  patches/$P/$ANDR/provisionals/${FILE}.out/smali/${FAIL} tmp/${FILE}.out/smali/${FAIL} >> "$LOG" || echo "FAILED to cp $FAIL" >> ${JAR}.log
					SID=(${SID[@]} $FAIL)
				done
			fi
			[[ `grep FAILED ${JAR}.log` != "" ]] &&  printerror "failed $NAME.patch"
			garbage tmp/${FILE}.out
			if [ -f patches/$P/$A/$R/$B/{JAR}.sh ]; then
				printtask "... apply $JAR.sh ..."
				. patches/$P/$A/$R/$B/{JAR}.sh 2>&1 > ${JAR}.log
				cat ${JAR}.log | tee -a "$LOG"
			fi
		done

		[[ -n ${APKS[@]} ]] && printtask "### apk patch $P/$R/$B ###"
		for FILE in ${APKS[@]}; do
                    APK=${FILE##*/}
                    if [ -s tmp/${FILE}.out ] ; then
			printtask "... apply $APK.patch ..."
				patch -Nls -p2 -d tmp/${FILE}.out < $PARB/${APK}.patch 2>&1 >> ${APK}.log 
				cat ${APK}.log | tee -a "$LOG"
			[[ `grep FAILED ${APK}.log` != "" ]] && printerror "failed $APK.patch"
			garbage tmp/${FILE}.out
                    else
                        echo "No $APK in your ROM. Not able to patch this file."
                        echo "## No $APK in ROM ###" >> "$LOG"
                    fi
		done
		[[ -n ${IMGS[@]} ]] && printtask "### img patch $P/$A/$R/$B ###"
		for FILE in ${IMGS[@]}; do
			IMG=${FILE##*/}
			#NAME=${IMG%.img}
			echo "... applying $IMG.patch ..."
			patch -Nls -p1 -d boot/ramdisk < $PARB/${IMG}.patch >> "$LOG" || printerror "failed patching $FILE"
			# Special Instructions- married to boot.img patching by necessity, not design. When 
			# added to it's own section, it only runs for one mod. WIP.
			#if [ -f patches/$P/$R/special_instructions.sh ]; then
			#	. patches/$P/$R/special_instructions.sh
			#elif [ -f patches/$P/special_instruction.sh ]; then
			#	. patches/$P/special_instructions.sh
			#fi
		done

		[[ -n ${TXTS[@]} ]] && printtask "### text patch $P/$A/$R/$B ###"
		for FILE in ${TXTS[@]}; do
			TXT=${FILE##*/}
			if [[ -f $PARB/${TXT}.patch ]]; then
				printtask "... apply $TXT.patch ..."
				patch -Nls -p2 -d system/ < $PARB/${TXT}.patch 2>&1 > ${TXT}.log 
				#cat ${TXT}.log | tee -a "$LOG"
				[[ `grep FAILED ${TXT}.log` != "" ]] && printerror "failed $TXT.patch"
			fi
			if [[ -f $PAR/${TXT}.awk ]]; then
				printtask "... apply $TXT.awk ..."
				awk -f $PAR/${TXT}.awk $FILE > text || printerror "failed $TXT.awk"
				mv text $FILE
			fi
			if [[ -f $PAR/${TXT}.sed ]]; then
				printtask "... apply $TXT.sed ..."
				sed -f $PAR/${TXT}.sed $FILE > text || printerror "failed $TXT.sed"
				mv text $FILE
			fi
			if [[ -f $PAR/${TXT}.sh ]]; then
				printtask "... apply $TXT.sh ..."
				. $PAR/${TXT}.sh 2>&1 >> ${TXT}.log || printerror "failed $TXT.sh"
			fi
			garbage system/
		done
	done

# Rebuilding system files

	[[ -n ${JID[@]} ]] && printtask "### rebuild jar ###"
	for FILE in ${JID[@]}; do
		JAR=${FILE##*/}
		printtask "... rebuild $JAR ..."
		java -Xmx512M -jar smali.jar -a 15 tmp/${FILE}.out/smali -o tmp/${FILE}.out/classes.dex >> "$LOG" 2>> "$LOG"
		[ -f tmp/${FILE}.out/classes.dex ] || printerror "failed compiling $JAR !!!"
		jar -ufv ${FILE} -C tmp/${FILE}.out/ classes.dex >> "$LOG" 2>> "$LOG"
		if [ $FILE == "system/framework/framework.jar" ]; then
			jar -ufv ${FILE} -C tmp/${FILE}.out/ preloaded-classes >> "$LOG" 2>> "$LOG"
		fi
	done

	[[ -n ${AID[@]} ]] && printtask "### rebuild apk ###"
	for FILE in ${AID[@]}; do
		APK=${FILE##*/}
		printtask "... rebuild $APK ..."
		java -jar apktool.jar b tmp/${FILE}.out >> "$LOG" 2>> "$LOG" || printerror "failed compiling $FILE !!!"
		jar -ufv $FILE -C tmp/${FILE}.out/build/apk/ . > /dev/null 2>> "$LOG"
		#\rm -r tmp/${FILE}.out
	done	

	[[ -n ${IID[@]} ]] && printtask "### rebuild img ###"
	for FILE in ${IID[@]}; do
		printtask "### rebuild $FILE ###"
		case $FILE in
			boot.img)
				# Rebuilding boot.img
				cd boot
				printtask "... rebuilding ramdisk ..."
				./mkbootfs$EXE ./ramdisk | gzip > ramdisk-new.gz

				printtask "... composing boot.img ..."
				BASE=$(cat boot.img-base)
				# convert hex to decimal in cygwin by prefixing "0x" and C-style arithmetic
				PGSIZE=$((${PGFORM}$(cat boot.img-pagesize)))
				CMDLINE=$(cat boot.img-cmdline)
				echo "cmdline = no_console_suspend=1 console=null $CMDLINE" >> "$LOG"
				echo "pagesize = $PGSIZE" >> "$LOG"
				echo "base = $BASE" >> "$LOG"

				printtask "... rebuilding boot.img ..."
				./mkbootimg$EXE --kernel boot.img-zImage --ramdisk ramdisk-new.gz --cmdline "no_console_suspend=1 console=null $CMDLINE" --base "$BASE" --pagesize "$PGSIZE" -o ../boot.img || printerror "failed building boot.img"
				cd ..
				;;
			*)
				printerror "cannot process $FILE"
				;;
		esac
	done

	printtask "### create update.zip ###"
	jar -cfv tmp.zip ${IID[@]} ${JID[@]} ${AID[@]} ${CID[@]} ${TID[@]} META-INF >> "$LOG" 2>> "$LOG"
	java -jar signapk.jar updatecert.pem updatekey.pk8 tmp.zip update.zip 2>> "$LOG"
	#\rm -f tmp.zip

	#echo "# miscellaneous log" >> "$LOG"

	\mv restore.zip update.zip ..
	echo "### finished ###"
	echo "flash update.zip to install the modified"
	echo "flash restore.zip to restore the original"

	# add announcement
	for P in ${PID[@]}; do
                [ -d patches/$P/$ANDR ] && A=$ANDR || A=all
		[ -d patches/$P/$A/$RID ] && R=$RID || R=generic
		if [ -f patches/$P/$A/$R/README.txt ]; then
			cat patches/$P/$A/$R/README.txt
		elif [ -f patches/$P/$A/README.txt ]; then
			cat patches/$P/$A/README.txt
		fi
	done
fi
cd ..
\rm -rf "$TEMP"
