#!/bin/bash

# version: beta v1.9.8, patches 2012.09.04.

# PDroid created by svyat. Official PDroid thread is 
# http://forum.xda-developers.com/showthread.php?t=1357056

# The Auto-Patcher created by pastime1971 and mateorod
# Thread and support for the Auto-Patcher can be found at
# http://forum.xda-developers.com/showthread.php?p=27589651#post27589651

# ChangeLog
# 2012.05.00. (v0.1) 
# ...........
# 2012.05.12. (v0.2) allows user to specify a different version of patches
# 2012.05.13. (v0.3.0) force "patch -N", remove temp upon failure, generate log output
# 2012.05.13. (v0.3.1) revised the generation of updater-script (SGS2)
# 2012.05.15. added AOSP patches
# 2012.05.15. added crespo-aosp patches, added device-specific patching if patch exists
# 2012.05.15. remove restore.zip upon failure
# 2012.05.15. (v0.4.1) added CM7 (GB) patches
# 2012.05.18. (v0.4.2) added checking for tool commands
# 2012.05.21. (v0.4.3) apply device-specific patche only when it is specified
# 2012.05.26. added task title to log
# 2012.05.31. (v0.4.4) CM9 patches updated, crespo-aosp added
# 2012.06.04. (v0.4.5) added checking tools and rom, added aroma installer support, add patch outputs reroute
# 2012.06.15. CM9 patches updated
# 2012.06.16. (v0.4.6) AOKP patches updated, patch versions restructured
# 2012.06.17. (v0.5.0) patcher script reorganized, removed build.prop
# 2012.06.17. (v0.6.0) auto patcher script for pdroid and v6 patches
# 2012.06.19. (v0.6.1) add patches for CM7.2 Final
# 2012.06.20. (v0.6.2) updated CM 7.2 patches
# 2012.06.23. (v0.6.3) fix symlinks
# 2012.06.26. (v0.6.4) added 0618 patches for cm7 nightlies; removed 0619 cm7.2 final
# 2012.06.27. (v0.6.5) added new CM9 patches (20120626)
# 2012.06.27. (v0.6.6) added CM7 nightly patches (20120625) (finally!)
# 2012.07.02. (v0.7.0) Redid AOSP/AOKP; add Windows support (using Cygwin). Thanks kobik77!
# 2012.07.06. (v0.7.1) updated CM9 patches (20120706)
# 2012.07.08. (v0.7.2) updated AOKP (20120707) and CM9 (20120708) pdroid patches
# 2012.07.11. (v1.0.0) reworked script works on Linux, Mac OSX, and Windows (on Cygwin); 
# 		        added new ICS/JellyBean support for the new V6-Supercharger
# 2012.07.18. (v1.0.1) new CM7/CM9 Pdroid patches (20120718)
# 2012.07.23. (v1.0.2) updated CM9 patches (20120723)
# 2012.07.23. (v1.0.3) updated CM9 patches (20120724)
# 2012.08.06. (v1.5.0) updated smali/baksmali binaries to 1.33
# 2012.08.06. 	       Added Pdroid/V6supercharger support for CM10 Jellybean!
# 2012.08.06.	       Improved PDroid stability and efficiency (Thanks CollegeDev)
# 2012.08.06. (v1.6.0) added aokp-jb patches for pdroid/v6supercharger, script update
# 2012.08.17. (v1.9.5) Added support for pdroid_addon, by CollegeDev.
#		       Added insecure boot.img mod
#		       Added support for aosp-jb (This needs testing, and may not be
#		              a wide patch due to large variation between AOSP roms. 
#                      		          -Please report all experiences!
#		       Updated all v6supercharger patches w/new edits to ProcessList
#                      Major script overhaul in preparation for additional mods!
# 2012.08.20. (1.9.6) Conditional support for Official cm10 and aokp-jb builds
# 2012.08.23. (1.9.7) Final/confirmed pdroid support for Official CM10 and AOKP-JB
# 2012.09.04  (1.9.8) Bundled cygwin-compatible tools (original was corrupt).
#						 For Cygwin, replaced h2b function with simple bash math
#						 conversion (req'd for compat w/ Cygwin tools).
# 2012.08.26. (2.0.0) Added .apk patching
#					  Added 3G Dongle support for Nexus 7
#                     TabletUI support for Nexus 7 (maybe more)
#					  Google Voice support for Nexus 7
#						mods are 3gdongle, tabletUI, voice, or nexus7suite (for all)
#					  Added provisional file copy menu to widen patching base

# SHELL PROGRAMMING NOTES:
# [ -s FILE ] 
# [[ -n STRING ]] or [[ -z STRING ]] 

echo " "
echo "The Auto-Patcher v1.9.8"
echo " "
# by pastime1971 and mateorod
    	

# pass variables to children
set -a

# function for converting hex to binary- for testing
#function h2b { echo "obase=2; ibase=16; $( echo "$*" | sed -e 's/0x//g' -e 's/\([a-z]\)/\u\1/g' )" | bc; }

printusage () {
	echo "smali auto patcher v1.9.8"
	echo "      pdroid 1.32 patches 2012.08.20."
	echo "      v6supercharger patches 2012.08.17."
	echo ""
	echo "usage: $0 ROM.ZIP MODS [ROMTYPE] [PATCHDATE]"
	echo ""
	echo "MODS can be pdroid,v6supercharger or pdroid or v6supercharger"
	echo "optional [ROMTYPE] can be cm9, aokp, etc."
	echo "optional [PATCHDATE] can be specified to use older patch versions."
	echo "try \"$0 ROM.ZIP -h\" to see what is available"
	echo ""
	exit
}

debug () {
	echo "! please refer to $LOG for any debugging"
	echo ""
	echo "! patching failed."
	echo "! it may be possible to patch $ROM using other patch version"
	echo ""
	[ -d "$TEMP" ] && \rm -rf "$TEMP"
	printusage
}

printerror () {
	echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
	echo "!!! error:" $@
	echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
	echo ""	
	debug
}

printtask () {
	echo "" >> "$LOG"
	echo $@ | tee -a "$LOG"
}

copyfailed () {
	echo ""
	echo "These are the files for which patching failed:"
	echo "---------------------------------------------"
	echo ""
	grep FAILED ${JAR}.log | sed -e "s/.*.\///"
	echo ""
	echo "---------------------------------------------"
	echo ""
	echo "We can try to add a premade copy of those files."
	echo "This sometimes works."
	echo ""
	echo "But IT MAY NOT WORK!!!"
	echo ""
	echo ""
	askconsent && return 0 || return 1
}

askconsent () {
	sleep 1
	echo -n "Do you want to proceed ? (YES/no) "
	read PROCEED
	case $PROCEED in
		[Yy] | [Yy][Ee][Ss])
			echo ""
			;;
		*)
			return 1;	# error
			;;
	esac
	echo -n "Are you sure ? (YES/no) "
	read PROCEED
	case $PROCEED in
		[Yy] | [Yy][Ee][Ss])
			return 0;	# successful
			;;
		*)
			return 1;	# error
			;;
	esac
}

abspath () {
	case `uname -s` in
	CYGWIN*)
		echo $(cygpath -ua "$1")
		;;
	Darwin)
		#[[ $(echo $1 | awk '/^\//') == $1 ]] && echo "$1" || echo "$PWD/$1"
		[[ ${1:0:1} == "/" ]] && echo "$1" || echo "$PWD/$1"
		;;
	Linux)
		echo $(readlink -f "$1")
		;;
	*)
		if [[ ${1:0:1} == "/" ]]; then
			echo "$1"
		elif [[ ${1:0:2} == "./" ]]; then
			echo "$PWD/${1:2}"
		else
			echo "$PWD/$1"
		fi
		;;
	esac
}

extpath () {
	case `uname -s` in
	CYGWIN*)
		echo $(cygpath -da "$1")
		;;
	*)
		echo $(abspath "$1")
		;;
	esac
}

#contains () { for e in "${@:2}"; do [[ "$e" = "$1" ]] && return 0; done; return 1; }

parse () { echo "${1%%_*}"; }

getbuildprop () {
if [ -f system/build.prop ]; then
	result=(`grep $1 system/build.prop | tr '=' ' '`)
	echo ${result[1]}
else
	echo ""
fi
}

proberom () {
	VID=$(getbuildprop ro.build.version.release)

	if [ "${VID%.*}" == "2.3" ]; then
		RID=cm7;
	elif [ "${VID%.*}" == "4.0" ]; then
		MID=$(getbuildprop ro.rommanager.developerid)
		[[ "$MID" == "" ]] && MID=$(parse $(getbuildprop ro.modversion))
		DID=$(getbuildprop ro.product.device)
		[[ "$DID" == "" ]] && DID=$(getbuildprop ro.build.product)

		case "$MID" in
		cm9|cm|cyanogenmod*)
			RID=cm9;
			;;
		aokp|teamkang)
			RID=aokp;
			;;
#		aosp|AOSP)	# AOSP probing does not work yet
#			RID=aosp;
#			;;
		*)
			RID=aosp; 
			echo "!!! $MID is not supported yet, trying generic latest !!!"
			;;
		esac
	elif [ "${VID%.*}" == "4.1" ]; then
		MID=$(getbuildprop ro.build.display.id)
		[[ "$MID" == "" ]] && MID=$(parse $(getbuildprop ro.build.display.id))
		DID=$(getbuildprop ro.product.device)
		[[ "$DID" == "" ]] && DID=$(getbuildprop ro.build.product)

		case "$MID" in
		cm10|cm*|cyanogenmod*)
			RID=cm10;
			;;
		aokp*|teamkang)
			RID=aokp-jb;
			;;
#		aosp|AOSP)	# AOSP probing does not work yet
#			RID=aosp
#			;;
		*)
			RID=aosp-jb;
			echo "!!! $MID may not be supported yet, trying aosp-jb latest !!!"
			;;
		esac
	else
		printerror "unknown ROM version $VID"
	fi
	printtask "... result of ROM check: version= $VID rom= $RID ..."
}

proberil () {
	RIL=$(getbuildprop ro.telephony.ril_class)
	[[ -n $RIL ]] && printtask "... result of ROM check: RIL= $RIL"
}

garbage () {
	unset GARBAGE
	GARBAGE=($(find $@ -name "*.orig")) && rm -rf ${GARBAGE[@]} && echo "GARBAGE=" ${GARBAGE[@]} >> "$LOG"
	GARBAGE=($(find $@ -name "*.rej"))  && rm -rf ${GARBAGE[@]} && echo "GARBAGE=" ${GARBAGE[@]} >> "$LOG"
}

[[ $# -lt 1 || $1 == "-h" || -z $1 ]] && printusage

ROOT=$(abspath `dirname "$0"`)
TOOL="$ROOT/patch_tools.tgz"
PTCH="$ROOT/patch_patches.tgz"
ROM=$(abspath "$1")
ROMX=$(extpath "$1")

if [[ $OSTYPE == "cygwin" ]]; then
	EXE=".exe"
	PGFORM="0x"
fi

DATE=`date +%Y%m%d%H%M%S`
TEMP=$(abspath ./tmp$DATE)
LOG=$(abspath ./log$DATE)
#echo $ROOT $TOOL $ROM $TEMP "$LOG"
echo "ROOT= $ROOT" >> "$LOG"
echo "TOOL= $TOOL" >> "$LOG"
echo "ROM=  $ROM" >> "$LOG"
echo "ROMX= $ROMX" >> "$LOG"

\rm -f restore.zip update.zip

#CHK=$(getconf LONG_BIT) 
#if [[ $CHK = "64" ]]; then
#	BIT=64
#else [[ $BIT = "32" ]];
#	BIT=32
#fi
#echo "*** You are using a $BIT bit OS   ***" >> "$LOG"
#echo "### You are using $BIT bit OS ###"

printtask "### verify tools ###"
which patch >> "$LOG" || printerror "Missing \"patch diff tools\""
which tar >> "$LOG" || printerror "Missing \"tar zip tools\""
which jar >> "$LOG" || printerror "Missing \"jar (JDK)\""
which java >> "$LOG" || printerror "Missing \"java (JRE)\""
which cpio >> "$LOG" || printerror "Missing \"cpio (JRE)\""
[ -f "$TOOL" ] || printerror "patch tool is missing"
[ -f "$PTCH" ] || printerror "patch patches are missing"
printtask "### verify ROM ###"
[ -f "$ROM" ] || printerror "Cannot find $ROM"
echo "# running" $0 $@ >> "$LOG"
mkdir "$TEMP"
cd "$TEMP"

PATH="$TEMP:$PATH"
export PATH
echo "PATH= $PATH" >> "$LOG"

printtask "### unzip patch tools ###"
tar xvzf "$TOOL" >> "$LOG" 2>> "$LOG" || printerror "failed extracting tools !!!"
# workaround for the recent cygwin filename issue
\mv cygwin/aapt.exe .
\mv cygwin/*.exe boot/
\rm -rf cygwin
printtask "### unzip patch patches ###"
tar xvzf "$PTCH" > /dev/null || printerror "failed extracting patches !!!"

# build date
if [ $# -gt 3 ]; then
	BID=$4
else
	BID=latest
fi
# rom type
if [ $# -gt 2 ]; then
	RID=$3
else
	printtask "### probe rom type ###"
	jar -xvf "$ROMX" system/build.prop 2>> "$LOG" || printerror "failed extracting build.prop from $ROMX !!!"
	proberom
fi
# ril type
proberil
# patch type
if [ $# -gt 1 ]; then
	PIL=${2//,/ }
else
	#PIL=`ls patches/`
	PIL="pdroid v6supercharger"
fi
# a hack to make sure pdroid is the first mod
[[ ${PIL[@]} =~ pdroid ]] && PID=(pdroid)
for P in ${PIL[@]}; do
	[[ ${PID[@]} =~ $P ]] || PID=(${PID[@]} $P)
done

echo "# VID=" $VID >> "$LOG"
echo "# MID=" $MID >> "$LOG"
echo "# RID=" $RID >> "$LOG"
echo "# DID=" $DID >> "$LOG"
echo "# BID=" $BID >> "$LOG"
echo "# PID=" ${PID[@]} >> "$LOG"

if [[ ( "$PID" == "-h"  || "$RID" == "-h" || "$BID" == "-h" ) ]]; then
	echo "### supported patch candidates ###"
	[ "$PID" != "-h" ] && PL=${PID[@]} || PL=`ls patches/`
	for P in ${PL[@]}; do
		[ "$PID" != "-h" -a "$RID" != "-h" ] && RL=${RID[@]} || RL=`ls patches/$P/`
		for R in ${RL[@]} ; do
			[ $R == "common" -o ! -d patches/$P/$R ] && continue
			echo -n "$P : $R : "
			\ls --ignore="*.sh" --ignore="*.txt" -r patches/$P/$R/
		done
	done
else
	for P in ${PID[@]}; do
		[ -d patches/$P ] || printerror "$P is not available"

		[ -d patches/$P/$RID ] && R=$RID || R=generic
		#[ -d patches/$P/$R/$BID ] && B=$BID || B=latest

		unset FILES
		[ -f patches/$P/files.txt ] && FILES=$(cat patches/$P/files.txt)
		[ -f patches/$P/$R/files.txt ] && FILES=$(cat patches/$P/$R/files.txt)
		for FILE in ${FILES[@]}; do
			case "$FILE" in
			+system/*)
				[[ ${CID[@]} =~ ${FILE:1} ]] && printerror "${FILE:1} is already being copied" || CID=(${CID[@]} ${FILE:1})
				;;
			-system/*)
				[[ ${EID[@]} =~ ${FILE:1} ]] || EID=(${EID[@]} ${FILE:1})
				;;
			system/*.jar)
				[[ ${JID[@]} =~ $FILE ]] || JID=(${JID[@]} $FILE)
				;;
			system/*.apk)
				[[ ${AID[@]} =~ $FILE ]] || AID=(${AID[@]} $FILE)
				;;
			*.img)
				[[ ${IID[@]} =~ $FILE ]] || IID=(${IID[@]} $FILE)
				;;
			system/*)
				[[ ${TID[@]} =~ $FILE ]] || TID=(${TID[@]} $FILE)
				;;
			esac
		done
	done
	echo "### DELETE FILES=" ${EID[@]} >> "$LOG"
	echo "### COPY FILES=" ${CID[@]} >> "$LOG"
	echo "### JAR FILES=" ${JID[@]} >> "$LOG"
	echo "### APK FILES=" ${AID[@]} >> "$LOG"
	echo "### IMG FILES=" ${IID[@]} >> "$LOG"
	echo "### TXT FILES=" ${TID[@]} >> "$LOG"

	printtask "### unzip rom ###"
	# extract system files
	jar -xvf "$ROMX" ${JID[@]} ${AID[@]} ${IID[@]} ${TID[@]} 2>> "$LOG" || printerror "failed extracting ${JID[@]} ${AID[@]} ${IID[@]} from $ROMX !!!"
	#\cp -a system/ backup	# only for debugging purpose

	printtask "### create updater script ###"
	jar -xvf "$ROMX" META-INF/com/google/android/updater-script META-INF/com/google/android/update-binary
	jar -xvf "$ROMX" META-INF/com/google/android/update-binary-installer 1> /dev/null 2> /dev/null
	if [ -f META-INF/com/google/android/update-binary-installer ]; then
		printtask "... using Aroma installer ..."
		\mv META-INF/com/google/android/update-binary-installer META-INF/com/google/android/update-binary
	else
		printtask "... using Clockworkmod installer ..."
	fi
	if [ -f META-INF/com/google/android/update-binary ]; then
		#echo "# original updater-script" >> "$LOG"
		#cat META-INF/com/google/android/updater-script >> "$LOG"

		cat META-INF/com/google/android/updater-script | grep ^mount | grep "/system" | head -n 1 > updater-script
		[ -s updater-script ] || echo "run_program(\"/sbin/busybox\", \"mount\", \"/system\");" > updater-script

		for FILE in ${EID[@]}; do
			# restore the original
			jar -xvf "$ROMX" $FILE 2> /dev/null || printtask "!!! warning $FILE cannot be restored !!!"
		done
		for FILE in ${CID[@]}; do
			# replace with the original or delete it
			jar -xvf "$ROMX" $FILE 2> /dev/null || echo "delete(\"/$FILE\");" >> updater-script
		done

		echo "package_extract_dir(\"system\", \"/system\");" >> updater-script
		# add permission management
		cat META-INF/com/google/android/updater-script | grep set_perm | grep "/system" >> updater-script
		# TODO: remove if we don't need it any more
		for P in ${PID[@]}; do
			if [ -s patches/$P/set_perm.txt ]; then
				echo "...adding permissions..."
				cat patches/$P/set_perm.txt >> updater-script
			fi
		done

		cat META-INF/com/google/android/updater-script | grep ^unmount | grep "/system" | head -n 1 >> updater-script

		[[ ${IID[@]} =~ boot.img ]] && cat META-INF/com/google/android/updater-script | grep "boot.img" >> updater-script

		cat updater-script > META-INF/com/google/android/updater-script

		echo "# generated updater-script" >> "$LOG"
		cat updater-script >> "$LOG"
	else
		# this is not enough any more
		jar -xvf update-template.zip META-INF/com/google/android/update-binary META-INF/com/google/android/updater-script
	fi

	printtask "### create restore.zip ###"
	#\rm -f system/build.prop	# user may have modified it	# now we handle build.prop as well
	jar -cfv tmp.zip ${JID[@]} ${AID[@]} ${IID[@]} META-INF >> "$LOG" 2>> "$LOG"
	java -jar signapk.jar updatecert.pem updatekey.pk8 tmp.zip signed.zip
	\mv signed.zip restore.zip
	\rm -f tmp.zip

	printtask "### decompile system files ###"
	# decompile system files
	for FILE in ${JID[@]}; do
		JAR=${FILE##*/}
		printtask "... decompile $JAR ..."
		java -jar baksmali.jar -b -a 15 -o tmp/${FILE}.out/smali ${FILE} >> "$LOG" 2>> "$LOG"
		if [ $FILE == "system/framework/framework.jar" ]; then
			printtask "... extract preloaded-classes ..."
			jar -xvf ${FILE} preloaded-classes >> "$LOG" 2>> "$LOG"
			\mv preloaded-classes tmp/${FILE}.out/
		fi
	done
	for FILE in ${AID[@]}; do
		APK=${FILE##*/}
		printtask "... decompile $APK ..."
		if [ $FILE == "system/framework/framework-res.apk" ]; then
			printtask "... installing framework files ..."
			java -jar apktool.jar if $FILE
		fi
		java -jar apktool.jar d -f $FILE tmp/$FILE.out
		
	done
	for FILE in ${IID[@]}; do
		printtask "### unpacking $FILE ###"
		case "$FILE" in
			boot.img)
				cd boot
				./unpackbootimg$EXE -i ../boot.img >> "$LOG" 2>> "$LOG"

				mkdir ramdisk
				cd ramdisk
				gzip -dc ../boot.img-ramdisk.gz | cpio -i >> "$LOG" 2>> "$LOG"
				cd ../../
				;;
			*)
				printerror "cannot process $FILE"
				;;
		esac
	done


	# apply system modification
	for P in ${PID[@]}; do
		[ -d patches/$P/$RID ] && R=$RID || R=generic
		[ -d patches/$P/$R/$BID ] && B=$BID || B=latest
		PR=patches/$P/$R
		PRB=patches/$P/$R/$B

		unset FILES COPY DELS JARS APKS IMGS TXTS
		[ -f patches/$P/files.txt ] && FILES=$(cat patches/$P/files.txt)
		[ -f patches/$P/$R/files.txt ] && FILES=$(cat patches/$P/$R/files.txt)
		for FILE in ${FILES[@]}; do
			case $FILE in
			+system/*)
				COPY=(${COPY[@]} ${FILE:1})
				;;
			-system/*)
				DELS=(${DELS[@]} ${FILE:1})
				;;
			system/*.jar)
				JARS=(${JARS[@]} $FILE)
				;;
			system/*.apk)
				APKS=(${APKS[@]} $FILE)
				;;
			*.img)
				IMGS=(${IMGS[@]} $FILE)
				;;
			system/*)
				TXTS=(${TXTS[@]} $FILE)
				;;
			esac
		done

		[[ -n ${COPY[@]} ]] && printtask "### copy patch $P/$R/$B ###"
		for FILE in ${COPY[@]}; do 
			printtask "... copying $FILE ..."
			DEST=${FILE%/*}
			mkdir -p ./$DEST
			if [ -e patches/$P/common/$FILE ]; then
				[ -e $FILE ] && printtask "... overwriting $FILE from $P ..."
	 			\cp -a patches/$P/common/$FILE ./$DEST
			else
				printerror "$FILE is missing in the patch"
			fi
		done

		[[ -n ${DELS[@]} ]] && printtask "### delete patch $P/$R/$B ###"
		for FILE in ${DELS[@]}; do 
			printtask "... deleting $FILE ..."
	 		\rm -rf ./$FILE
		done

		[[ -n ${JARS[@]} ]] && printtask "### jar patch $P/$R/$B ###"
		for FILE in ${JARS[@]}; do
			JAR=${FILE##*/}
			NAME=${JAR%.jar}
			printtask "... apply $NAME.patch ..."
			patch -Nls -p1 -d tmp/${FILE}.out < $PRB/${NAME}.patch 2>&1 > ${JAR}.log
			cat ${JAR}.log | tee -a "$LOG"
			case "$NAME" in
			framework)
				# patch preloaded-classes only if a patch exists
				if [ -f $PRB/preloaded.patch ]; then
					printtask "... apply preloaded.patch ..."
					patch -Nls -p1 -d tmp/${FILE}.out < $PRB/preloaded.patch 2>&1 > preloaded.log
					cat preloaded.log | tee -a "$LOG"
					[[ `grep FAILED preloaded.log` != "" ]] && printerror "failed preloaded.patch"
				fi
				;;
			*)
				echo -n ""	# do nothing else
				;;
			esac
			# substitute failed smali with premade jar
			FAILS=(`grep FAILED ${JAR}.log | sed -e 's/.*smali\///' | sed -e 's/\.rej//'`)
			if [[ -n ${FAILS[@]} ]]; then
				printtask "!!! PATCHING FAILED FOR ${FAILS[@]} !!!"
				for FAIL in ${FAILS[@]}; do
					[[ ${SID[@]} =~ $FAIL ]] && printerror "$FAIL was already replaced before"
					copyfailed || printerror "failed $NAME.patch"
					printtask "... replace $FAIL ..."
					\rm -rf tmp/${FILE}.out/smali/${FAIL}
					\cp -a  patches/$P/common/provisionals/${FILE}.out/smali/${FAIL} tmp/${FILE}.out/smali/${FAIL} || echo "FAILED to cp $FAIL" >> ${JAR}.log
					#echo "### replacing ${FAILS[@]} from patches/$P/common/${FILE} ###" > ${JAR}.log
					#java -jar baksmali.jar -b -a 15 -o pmp/${FILE}.out/smali patches/$P/common/provisionals/${FAIL} >> "$LOG" 2>> "$LOG" || echo "FAILED to baksmali $FILE" >> ${JAR}.log
					#\cp -a  pmp/${FILE}.out/smali/${FAIL} tmp/${FILE}.out/smali/${FAIL} || echo "FAILED to cp $FAIL" >> ${JAR}.log
					SID=(${SID[@]} $FAIL)
				done
			fi
			[[ `grep FAILED ${JAR}.log` != "" ]] &&  printerror "failed $NAME.patch"
			garbage tmp/${FILE}.out
			if [ -f patches/$P/$R/${JAR}.sh ]; then
				printtask "... apply $JAR.sh ..."
				. patches/$P/$R/${JAR}.sh 2>&1 > ${JAR}.log
				cat ${JAR}.log | tee -a "$LOG"
			fi
		done

		[[ -n ${APKS[@]} ]] && printtask "### apk patch $P/$R/$B ###"
		for FILE in ${APKS[@]}; do
			APK=${FILE##*/}
			#NAME=${APK%.apk}
			printtask "... apply $APK.patch ..."
				patch -Nls -p2 -d tmp/${FILE}.out < $PRB/${APK}.patch 2>&1 >> ${APK}.log 
				cat ${APK}.log | tee -a "$LOG"
			[[ `grep FAILED ${APK}.log` != "" ]] && printerror "failed $APK.patch"
			garbage tmp/${FILE}.out
		done

		[[ -n ${IMGS[@]} ]] && printtask "### img patch $P/$R/$B ###"
		for FILE in ${IMGS[@]}; do
			IMG=${FILE##*/}
			#NAME=${IMG%.img}
			echo "... applying $IMG.patch ..."
			patch -Nls -p1 -d boot/ramdisk < $PRB/${IMG}.patch || printerror "failed patching $FILE"
			# Special Instructions- married to boot.img patching by necessity, not design. When 
			# added to it's own section, it only runs for one mod. WIP.
			#if [ -f patches/$P/$R/special_instructions.sh ]; then
			#	. patches/$P/$R/special_instructions.sh
			#elif [ -f patches/$P/special_instruction.sh ]; then
			#	. patches/$P/special_instructions.sh
			#fi
		done

		[[ -n ${TXTS[@]} ]] && printtask "### text patch $P/$R/$B ###"
		for FILE in ${TXTS[@]}; do
			TXT=${FILE##*/}
			if [[ -f $PRB/${TXT}.patch ]]; then
				printtask "... apply $TXT.patch ..."
				patch -Nls -p2 -d system/ < $PRB/${TXT}.patch 2>&1 > ${TXT}.log 
				#cat ${TXT}.log | tee -a "$LOG"
				[[ `grep FAILED ${TXT}.log` != "" ]] && printerror "failed $TXT.patch"
			fi
			if [[ -f $PR/${TXT}.awk ]]; then
				printtask "... apply $TXT.awk ..."
				awk -f $PR/${TXT}.awk $FILE > text || printerror "failed $TXT.awk"
				mv text $FILE
			fi
			if [[ -f $PR/${TXT}.sed ]]; then
				printtask "... apply $TXT.sed ..."
				sed -f $PR/${TXT}.sed $FILE > text || printerror "failed $TXT.sed"
				mv text $FILE
			fi
			if [[ -f $PR/${TXT}.sh ]]; then
				printtask "... apply $TXT.sh ..."
				. $PR/${TXT}.sh 2>&1 >> ${TXT}.log || printerror "failed $TXT.sh"
			fi
			garbage system/
		done
	done

	[[ -n ${JID[@]} ]] && printtask "### rebuild jar ###"
	for FILE in ${JID[@]}; do
		JAR=${FILE##*/}
		printtask "... rebuild $JAR ..."
		java -Xmx512M -jar smali.jar -a 15 tmp/${FILE}.out/smali -o tmp/${FILE}.out/classes.dex >> "$LOG" 2>> "$LOG"
		[ -f tmp/${FILE}.out/classes.dex ] || printerror "failed compiling $JAR !!!"
		jar -ufv ${FILE} -C tmp/${FILE}.out/ classes.dex >> "$LOG" 2>> "$LOG"
		if [ $FILE == "system/framework/framework.jar" ]; then
			jar -ufv ${FILE} -C tmp/${FILE}.out/ preloaded-classes >> "$LOG" 2>> "$LOG"
		fi
	done

	[[ -n ${AID[@]} ]] && printtask "### rebuild apk ###"
	for FILE in ${AID[@]}; do
		APK=${FILE##*/}
		printtask "... rebuild $APK ..."
		java -jar apktool.jar b tmp/${FILE}.out >> "$LOG" 2>> "$LOG" || printerror "failed compiling $FILE !!!"
		jar -ufv $FILE -C tmp/${FILE}.out/build/apk/ . >> "$LOG" 2>> "$LOG"
		#\rm -r tmp/${FILE}.out
	done	

	[[ -n ${IID[@]} ]] && printtask "### rebuild img ###"
	for FILE in ${IID[@]}; do
		printtask "### rebuild $FILE ###"
		case $FILE in
			boot.img)
				# Rebuilding boot.img
				cd boot
				printtask "... rebuilding ramdisk ..."
				./mkbootfs$EXE ./ramdisk | gzip > ramdisk-new.gz

				printtask "... composing boot.img ..."
				BASE=$(cat boot.img-base)
				# convert hex to decimal in cygwin by prefixing "0x" and C-style arithmetic
				PGSIZE=$((${PGFORM}$(cat boot.img-pagesize)))
				CMDLINE=$(cat boot.img-cmdline)
				echo "cmdline = no_console_suspend=1 console=null" $CMDLINE >> "$LOG"
				echo "pagesize =" $PGSIZE >> "$LOG"
				echo "base =" $BASE >> "$LOG"

				printtask "... rebuilding boot.img ..."
				./mkbootimg$EXE --kernel boot.img-zImage --ramdisk ramdisk-new.gz --cmdline "no_console_suspend=1 console=null $CMDLINE" --base "$BASE" --pagesize "$PGSIZE" -o ../boot.img || printerror "failed building boot.img"
				cd ..
				;;
			*)
				printerror "cannot process $FILE"
				;;
		esac
	done

	printtask "### create update.zip ###"
	jar -cfv tmp.zip ${IID[@]} ${JID[@]} ${AID[@]} ${CID[@]} ${TID[@]} META-INF >> "$LOG" 2>> "$LOG"
	java -jar signapk.jar updatecert.pem updatekey.pk8 tmp.zip update.zip
	\rm -f tmp.zip

	#echo "# miscellaneous log" >> "$LOG"

	\mv restore.zip update.zip ..
	echo "### finished ###"
	echo "flash update.zip to install the modified"
	echo "flash restore.zip to restore the original"

	# add announcement
	for P in ${PID[@]}; do
		[ -d patches/$P/$RID ] && R=$RID || R=generic
		if [ -f patches/$P/$R/README.txt ]; then
			cat patches/$P/$R/README.txt
		elif [ -f patches/$P/README.txt ]; then
			cat patches/$P/README.txt
		fi
	done
fi
cd ..
\rm -rf "$TEMP"
